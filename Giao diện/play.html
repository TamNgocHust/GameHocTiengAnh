<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Play - Mushroom Kingdom Runner</title>

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", Arial, sans-serif;
    }

    body {
        height: 100vh;
        width: 100vw;
        background: #000; /* n·ªÅn ngo√†i canvas */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .overlay-ui {
        position: fixed;
        inset: 0;
        pointer-events: none; /* ƒë·ªÉ chu·ªôt click v√†o canvas/box b√¨nh th∆∞·ªùng */
    }

    .top-right {
        position: absolute;
        top: 15px;
        right: 20px;
        background: rgba(255, 245, 210, 0.95);
        padding: 8px 16px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 0.9rem;
        color: #553300;
        border: 2px solid #ffb347;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
        pointer-events: auto;
    }

    .username-label {
        font-weight: 600;
    }

    .logout-btn {
        cursor: pointer;
        padding: 4px 10px;
        border-radius: 999px;
        border: none;
        background: #ff4b3a;
        color: #fff;
        font-size: 0.85rem;
        box-shadow: 0 3px 0 #c53120;
        text-transform: uppercase;
    }

    .logout-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 0 #c53120;
    }

    .logout-btn:active {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #c53120;
    }

    .bottom-left {
        position: absolute;
        left: 20px;
        bottom: 15px;
        pointer-events: auto;
    }

    .btn-back {
        padding: 7px 16px;
        border-radius: 999px;
        border: none;
        background: #ffffff;
        color: #553300;
        font-size: 0.9rem;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    }

    .btn-back:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 0 rgba(0, 0, 0, 0.25);
    }

    .btn-back:active {
        transform: translateY(2px);
        box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
    }

    .btn-back span {
        font-size: 1.1rem;
    }

    /* CANVAS GAME */
    #gameWrapper {
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
        border: 4px solid #ff8c42;
    }

   canvas {
    display: block;
    background: #000; /* ho·∫∑c b·ªè h·∫≥n d√≤ng background */
}


    /* H·ªòP C√ÇU H·ªéI */
    #questionOverlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.45);
        display: flex;
        justify-content: center;
        align-items: center;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
    }

    #questionOverlay.show {
        visibility: visible;
        opacity: 1;
        pointer-events: auto;
    }

    .question-card {
        width: 420px;
        max-width: 95vw;
        background: #fff7e0;
        border-radius: 18px;
        border: 3px solid #ffb347;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.45);
        padding: 18px 20px 16px;
    }

    .question-title {
        font-size: 1.2rem;
        font-weight: 700;
        color: #d13625;
        text-shadow: 0 1px 0 #ffd76b;
        margin-bottom: 6px;
    }

    .question-text {
        font-size: 0.98rem;
        color: #333;
        margin-bottom: 10px;
    }

    .question-text strong {
        color: #c02626;
    }

    .question-options {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 6px;
    }

    .option-btn {
        padding: 8px 10px;
        border-radius: 12px;
        border: none;
        text-align: left;
        font-size: 0.95rem;
        cursor: pointer;
        background: #ffffff;
        color: #333;
        box-shadow: 0 3px 0 rgba(0, 0, 0, 0.18);
    }

    .option-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 0 rgba(0, 0, 0, 0.25);
    }

    .option-btn:active {
        transform: translateY(2px);
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
    }

    .question-message {
        font-size: 0.9rem;
        color: #553300;
        min-height: 18px;
        margin-bottom: 4px;
    }

    .question-note {
        font-size: 0.8rem;
        color: #777;
        font-style: italic;
    }

    /* HUD tr√™n canvas */
    .hud {
        position: absolute;
        top: 15px;
        left: 20px;
        color: #fff;
        font-size: 0.9rem;
        text-shadow: 0 2px 0 #000;
        pointer-events: none;
    }
</style>
</head>
<body>

<div id="gameWrapper">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <div class="hud" id="hudText"></div>

    <!-- H·ªôp c√¢u h·ªèi -->
    <div id="questionOverlay">
        <div class="question-card">
            <div class="question-title">Toad's Question</div>
            <div class="question-text" id="qText"></div>
            <div class="question-options" id="qOptions"></div>
            <div class="question-message" id="qMessage"></div>
            <div class="question-note">
                Tr·∫£ l·ªùi ƒë√∫ng ƒë·ªÉ Mario nh·∫£y qua ·ªëng c·ªëng v√† ti·∫øp t·ª•c h√†nh tr√¨nh!
            </div>
        </div>
    </div>
</div>

<!-- UI ngo√†i canvas (username, back, logout) -->
<div class="overlay-ui">
    <div class="top-right">
        <span class="username-label" id="showUser">User</span>
        <button class="logout-btn" onclick="logout()">Logout</button>
    </div>

    <div class="bottom-left">
        <button class="btn-back" onclick="goBack()">
            <span>‚Üê</span> Quay l·∫°i menu
        </button>
    </div>
</div>

<script>
    // ============ TH√îNG TIN USER ===============
    const currentUser = localStorage.getItem("currentUser");
    document.getElementById("showUser").textContent = currentUser ? currentUser : "User";

    function logout() {
        localStorage.removeItem("currentUser");
        localStorage.removeItem("role");
        window.location.href = "login.html";
    }

    function goBack() {
        window.location.href = "menu.html";
    }

    // ============ GAME SETUP ===============
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ·∫¢nh n·ªÅn Mushroom Kingdom
    const bgImg = new Image();
    bgImg.src = "screen/mushroom.jpg";   // ƒë√∫ng v·ªõi file b·∫°n ƒëang d√πng
    let bgReady = false;
    bgImg.onload = () => { bgReady = true; };

    const hudText = document.getElementById("hudText");
    const questionOverlay = document.getElementById("questionOverlay");
    const qText = document.getElementById("qText");
    const qOptions = document.getElementById("qOptions");
    const qMessage = document.getElementById("qMessage");

    // M·∫∑t ƒë·∫•t (·ªëng xanh & ch√¢n Mario s·∫Ω ƒë·ª©ng tr√™n line n√†y)
    const groundY = canvas.height - 10;

    // Nh√¢n v·∫≠t (khung logic, c√≤n vi·ªác v·∫Ω l√† do h√†m drawMarioPixel)
    const player = {
        x: 180,
        y: groundY - 72,
        width: 48,
        height: 72,
        vy: 0,
        onGround: true
    };

    let runPhase = 0; // d√πng ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng ch·∫°y

    const world = {
        speed: 3,
        coins: 0,
        pipesPassed: 0,
        state: "running" // running | question | jumping | finished
    };

    // 3 ·ªëng xanh = 3 c√¢u h·ªèi
    const pipes = [
        { x: 600,  width: 70, height: 120, asked: false, passed: false, qIndex: 0 },
        { x: 1050, width: 70, height: 120, asked: false, passed: false, qIndex: 1 },
        { x: 1500, width: 70, height: 120, asked: false, passed: false, qIndex: 2 }
    ];

    // C√¢u h·ªèi demo ‚Äì c√≥ th·ªÉ th√™m sau
    const questions = [
        {
            text: 'Toad ch·ªâ v√†o m·ªôt <strong>qu·∫£ t√°o</strong> v√† h·ªèi: "What is this?"',
            options: ["Banana", "Apple", "Dog", "Blue"],
            correctIndex: 1
        },
        {
            text: 'Toad th·∫•y m·ªôt con <strong>ch√≥</strong> ƒëang ch·∫°y. Toad h·ªèi: "What is this animal?"',
            options: ["Cat", "Cow", "Dog", "Fish"],
            correctIndex: 2
        },
        {
            text: 'Toad ch·ªâ l√™n b·∫ßu tr·ªùi v√† h·ªèi: "What color is the sky?"',
            options: ["Green", "Blue", "Red", "Yellow"],
            correctIndex: 1
        }
    ];

    let currentQuestionPipe = null;
    let currentQuestionIndex = null;

    // ============ GAME LOOP ===============
    let lastTime = 0;
    requestAnimationFrame(loop);

    function loop(timestamp) {
        const delta = timestamp - lastTime;
        lastTime = timestamp;

        update(delta);
        draw();

        requestAnimationFrame(loop);
    }

    function update(delta) {
        if (world.state === "running" || world.state === "jumping") {
            // Th·∫ø gi·ªõi (·ªëng) ch·∫°y ng∆∞·ª£c l·∫°i
            pipes.forEach(pipe => {
                pipe.x -= world.speed;
            });
        }

        // Hi·ªáu ·ª©ng ch·∫°y: nh√∫n nh·∫π
        if (world.state === "running") {
            runPhase += delta * 0.015;
        } else {
            runPhase = 0;
        }

        // Physics nh·∫£y
        if (world.state === "jumping") {
            player.vy += 0.7; // gravity
            player.y += player.vy;

            if (player.y >= groundY - player.height) {
                player.y = groundY - player.height;
                player.vy = 0;
                world.state = "running";
            }
        }

        // G·∫∑p ·ªëng th√¨ hi·ªán c√¢u h·ªèi
        if (world.state === "running") {
            const nextPipe = pipes.find(p => !p.asked && !p.passed && isCollidingWithPipeFront(player, p));
            if (nextPipe) {
                world.state = "question";
                nextPipe.asked = true;
                currentQuestionPipe = nextPipe;
                currentQuestionIndex = nextPipe.qIndex;
                showQuestion(currentQuestionIndex);
            }
        }

        // ·ªêng ƒë√£ ƒë∆∞·ª£c v∆∞·ª£t qua
        pipes.forEach(p => {
            if (!p.passed && p.x + p.width < player.x - 30) {
                p.passed = true;
                world.pipesPassed++;
            }
        });

        // Ho√†n th√†nh m√†n
        if (world.pipesPassed === pipes.length && world.state !== "finished") {
            world.state = "finished";
            showFinishMessage();
        }

        hudText.textContent = `Coins: ${world.coins}   Pipes: ${world.pipesPassed}/${pipes.length}`;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ·∫¢nh n·ªÅn Mushroom Kingdom
        if (bgReady) {
            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        } else {
            const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grd.addColorStop(0, "#6dd2ff");
            grd.addColorStop(1, "#89e1ff");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // ·ªêng xanh
        pipes.forEach(pipe => {
            ctx.fillStyle = "#0f9b3d";
            ctx.fillRect(pipe.x, groundY - pipe.height, pipe.width, pipe.height);
            ctx.fillStyle = "#16c157";
            ctx.fillRect(pipe.x - 4, groundY - pipe.height - 18, pipe.width + 8, 18);
        });

        // Mario pixel + hi·ªáu ·ª©ng ch·∫°y/nh·∫£y
        let offsetY = 0;
        if (world.state === "running") {
            offsetY = Math.sin(runPhase) * 3;
        }

        const centerX = player.x + player.width / 2;       // t√¢m ngang nh√¢n v·∫≠t
        const bottomY = player.y - offsetY + player.height; // ch√¢n nh√¢n v·∫≠t

        drawMarioPixel(ctx, centerX, bottomY, world.state, runPhase);
    }

    function isCollidingWithPipeFront(pl, pipe) {
        // Khi c·∫°nh ph·∫£i c·ªßa Mario ch·∫°m g·∫ßn ·ªëng
        return (
            pl.x + pl.width >= pipe.x - 5 &&
            pl.x + pl.width <= pipe.x + pipe.width + 5 &&
            !pipe.asked
        );
    }

    // ============ QUESTION LOGIC ===============
    function showQuestion(index) {
        const q = questions[index];
        if (!q) {
            world.state = "running";
            return;
        }

        qText.innerHTML = q.text;
        qOptions.innerHTML = "";
        qMessage.textContent = "";

        q.options.forEach((opt, idx) => {
            const btn = document.createElement("button");
            btn.className = "option-btn";
            btn.innerHTML = opt;
            btn.onclick = () => answerQuestion(idx);
            qOptions.appendChild(btn);
        });

        questionOverlay.classList.add("show");
    }

    function answerQuestion(selectedIndex) {
        const q = questions[currentQuestionIndex];
        if (!q) return;

        if (selectedIndex === q.correctIndex) {
            qMessage.textContent = "üëç Ch√≠nh x√°c! Mario nh·∫£y qua ·ªëng v√† nh·∫≠n 10 coin!";
            world.coins += 10;

            setTimeout(() => {
                questionOverlay.classList.remove("show");
                world.state = "jumping";
                player.vy = -22; // nh·∫£y cao qua ·ªëng
                if (currentQuestionPipe) {
                    currentQuestionPipe.passed = true;
                }
                currentQuestionPipe = null;
            }, 600);
        } else {
            qMessage.textContent = "‚ùå Ch∆∞a ƒë√∫ng r·ªìi, th·ª≠ ch·ªçn l·∫°i ƒë√°p √°n kh√°c nh√©!";
        }
    }

    function showFinishMessage() {
        hudText.textContent += "  |  Ho√†n th√†nh Mushroom Kingdom! üéâ";
        saveGameResult();
    }

    function saveGameResult() {
        const username = localStorage.getItem("username") || localStorage.getItem("currentUser") || "unknown";
        const className = localStorage.getItem("class") || "unknown";
        const role = localStorage.getItem("role") || "student";

        if (role !== "student") return;

        const correct = world.coins / 10;
        const total = questions.length;
        const score = Math.round((correct / total) * 100);

        const result = {
            username,
            className,
            world: "Mushroom Kingdom Runner",
            worldKey: "mushroom-run",
            correct,
            total,
            score,
            coins: world.coins,
            playedAt: new Date().toISOString()
        };

        const key = "gameResults";
        let list = [];
        try {
            list = JSON.parse(localStorage.getItem(key)) || [];
        } catch (e) {
            list = [];
        }
        list.push(result);
        localStorage.setItem(key, JSON.stringify(list));
    }

    // ============ V·∫º MARIO PIXEL ===============
    // cx, by: t√¢m ngang & v·ªã tr√≠ CH√ÇN (bottomY)
    // state: "running" | "jumping"
    // phase: d√πng ƒë·ªÉ vung ch√¢n khi ch·∫°y
    // ============ V·∫º MARIO PIXEL PRO ===============
// cx, by: t√¢m ngang & v·ªã tr√≠ CH√ÇN (bottomY)
// state: "running" | "jumping" | "question" | "finished"
// phase: d√πng ƒë·ªÉ chuy·ªÉn frame khi ch·∫°y
// ============ V·∫º MARIO PIXEL CH·∫†Y NGHI√äNG ===============
// cx, by: t√¢m ngang & v·ªã tr√≠ CH√ÇN (bottomY)
// state: "running" | "jumping" | "question" | "finished"
// phase: d√πng ƒë·ªÉ chuy·ªÉn frame khi ch·∫°y
function drawMarioPixel(ctx, cx, by, state, phase) {
    const u = 3; // 1 "pixel" = 3px (c√≥ th·ªÉ ch·ªânh 2/4 tu·ª≥ b·∫°n)

    // B·∫£ng m√†u
    const palette = {
        " ": null,           // trong su·ªët
        "K": "#111827",      // vi·ªÅn ƒë·∫≠m / outline
        "R": "#e11d48",      // ƒë·ªè m≈© / √°o
        "r": "#b91c1c",      // ƒë·ªè ƒë·∫≠m
        "B": "#2563eb",      // xanh y·∫øm
        "b": "#1d4ed8",      // xanh ƒë·∫≠m
        "S": "#fed7aa",      // da
        "s": "#f97316",      // da ƒë·∫≠m / m√°
        "H": "#92400e",      // t√≥c / ria
        "Y": "#facc15",      // c√∫c √°o
        "W": "#f9fafb"       // tr·∫Øng m·∫Øt / gƒÉng
    };

    // Sprite 18x18 ‚Äì Mario ch·∫°y nghi√™ng, ch√¢n tay d·∫°ng running pose
    const SPRITES = {
        run1: [
            "      KRRRRR      ",
            "    KRRRRRRRRK    ",
            "   KRRRRRRRRRRK   ",
            "   KRRRWRRRRRRK   ",
            "   K HSSSSSSHK    ",
            "  K HSSSWSSSHK    ",
            "  K HSSSSSSSHK    ",
            "   K HSSSSH K     ",
            "    KRRRSSRRK     ",
            "   KRRRBBBRRK     ",
            "   KRRBbBBBbK     ",
            "   KRRBbBBBbK     ",
            "    KRRBYYBBK     ",
            "     KRBYYBBK     ",
            "      KHS WH      ",
            "     BKB  WH      ",
            "    BKB          ",
            "    KKK          "
        ],
        // Ch√¢n ƒë·ªïi b√™n ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng ch·∫°y
        run2: [
            "      KRRRRR      ",
            "    KRRRRRRRRK    ",
            "   KRRRRRRRRRRK   ",
            "   KRRRWRRRRRRK   ",
            "   K HSSSSSSHK    ",
            "  K HSSSWSSSHK    ",
            "  K HSSSSSSSHK    ",
            "   K HSSSSH K     ",
            "    KRRRSSRRK     ",
            "   KRRRBBBRRK     ",
            "   KRRBbBBBbK     ",
            "   KRRBbBBBbK     ",
            "    KRRBYYBBK     ",
            "   B KRBYYBBK     ",
            "   B  KHS WH      ",
            "   BKB  WH        ",
            "   BKB           ",
            "   KKK           "
        ],
        // Nh·∫£y: th√¢n h∆°i thu l·∫°i, hai ch√¢n co nh∆∞ ƒëang bay qua ·ªëng
        jump: [
            "      KRRRRR      ",
            "    KRRRRRRRRK    ",
            "   KRRRRRRRRRRK   ",
            "   KRRRWRRRRRRK   ",
            "   K HSSSSSSHK    ",
            "  K HSSSWSSSHK    ",
            "  K HSSSSSSSHK    ",
            "   K HSSSSH K     ",
            "    KRRRSSRRK     ",
            "   KRRRBBBRRK     ",
            "   KRRBbBBBbK     ",
            "   KRRBbBBBbK     ",
            "    KRRBYYBBK     ",
            "     KRBYYBBK     ",
            "      BBBBB       ",
            "      BBBBB       ",
            "      KKKKK       ",
            "      KKKKK       "
        ]
    };

    // Ch·ªçn sprite theo tr·∫°ng th√°i
    let sprite;
    if (state === "jumping") {
        sprite = SPRITES.jump;
    } else if (state === "running") {
        const frame = Math.floor(phase * 0.2) % 2; // ƒë·ªïi frame ch·∫°y
        sprite = frame === 0 ? SPRITES.run1 : SPRITES.run2;
    } else {
        sprite = SPRITES.run1; // idle
    }

    const rows = sprite.length;
    const cols = sprite[0].length;

    // by l√† CH√ÇN, n√™n topY = by - rows*u
    const topY = by - rows * u;
    const leftX = cx - (cols * u) / 2;

    // V·∫Ω t·ª´ng "pixel"
    for (let y = 0; y < rows; y++) {
        const row = sprite[y];
        for (let x = 0; x < cols; x++) {
            const ch = row[x];
            const color = palette[ch];
            if (!color) continue;
            ctx.fillStyle = color;
            ctx.fillRect(leftX + x * u, topY + y * u, u, u);
        }
    }
}


</script>



</body>
</html>
